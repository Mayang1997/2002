<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
函数
        + 我们计算机语言了面的函数, 不是数学的函数
          => 跟数学一点关系都没有
          => 是在计算机语言里面, 帮我们做事情的东西, 我们叫做函数
        + 是把一段代码放在一个盒子里面
          => 我每次使用这个盒子的时候, 就是在使用这个盒子里面的代码
        + 和变量比较一下
          => 变量是准备了一个盒子, 存储一个值
          => 函数是准备了一个盒子, 存储一段 JS 代码
        + 函数的特点
          1. 使代码更加简洁
          2. 重复使用
          3. 调用时机

函数的创建
          + 两种方式
            1. 声明式函数
            2. 赋值式函数
          + 声明完毕的函数时不会执行的
            => 只是做了一个函数放在内存中
            => 但是函数内部的代码并不会执行
            => 微波炉, 买回来就时放在那里, 我不使用它的时候, 它是不会给我加热东西
              + 当我打开开关的时候, 才会开始转转转, 加热东西
  
        声明式函数
          + 语法: function 函数名() {}
            => function: 声明函数的关键字
            => 空格: 分隔关键字和函数名使用的
            => 函数名: 就是我们自己定义的一个名字, 遵循变量命名规则和规范
            => (): 形参, 一会再说, 必须写
            => {}: 大括号里面就是我们这个函数帮我们保存的一段 JS 代码
  
        赋值式函数
          + 语法: var 函数名 = function () {}
            => 前面需要一个 var
            => 把函数名提到前面来了

函数的执行
            + 一个函数创建出来以后, 是不会自动执行的
              => 需要我们来 启动(调用) 这个函数, 那么函数里面的代码才会执行
            + 启动方式
              1. 直接执行
              2. 依赖行为执行
    
          直接执行:
            + 语法: 函数名()
              => 函数名: 表示你需要让哪一个函数执行
              => (): 就是让你确定的这个函数执行以下
                -> 也就是把你定义的时候存放在里面的代码执行一遍
                -> 实参: 一会再说
    
          依赖事件执行
            + 我们把这个函数依托在页面中某一个元素的事件上
              => 当这个元素触发这个事件的时候, 就会执行对应的函数
            + 比如: 我把 weibolu 这个函数依托在页面的一个 div 元素的 点击行为上
              => 当你点击页面中的这个 div 的时候, 就会执行 weibolu 这个函数
            + 语法:
              => 指定页面元素.onclick = 函数名
              => 怎么找到指定元素, 页面中元素身上的 id 属性, 就可以在 JS 里面直接表示这个元素
              => 找到页面元素, 只能使用元素的 id 来直接使用
                -> className 标签名 不能直接使用
    
函数调用上的区别:
            + 声明式函数可以在声明之前调用, 也可以在声明之后调用
            + 赋值式函数只能在声明之后调用, 声明之前调用会报错
  


函数的参数
            + 参数分成两种
              => 形参: 函数 定义 的时候写在小括号里面的内容
                -> 就是一个在函数里面使用的变量
                -> 只不过这个变量的值由调用函数的时候的实参决定
              => 实参: 函数 调用 的时候写在小括号里面的内容
                -> 就是在调用函数的时候给形参进行赋值的
            + 多个参数
              => 一个函数定义形参, 理论上可以写无限个
                -> 多个形参之间用 逗号 分隔
                -> 不建议写太多(一般多的就是 4 个左右)
              => 一个函数调用的时候, 理论上也可以给形参写多个
                -> 多个实参之间用 逗号 分隔
                -> 不建议写太多, 和形参一一对应
            + 参数是怎么存储的
              => 当我们定义一个函数的时候, 会在内存空间中开辟一块空间
                -> 也就是我们所说的一个 "盒子", 存放一段代码
              => 所有的形参, 都是在这个内存空间中的一个一个的变量
    
    
         定义一个函数
           我需要的形参就写在函数名后面的 小括号 里面
         function bingxiang(dongwu) {
            在函数内部 dongwu 这个形参就是一个只能在函数内部使用的变量
            现在函数内部有一个变量叫做 dongwu, 只不过还没有赋值
           console.log('我要呜呜呜 开始把 ' + dongwu + ' 冻起来')
         }
    
         调用一个函数
           我给函数传递的实参, 就写在函数名后面的小括号里面
           本次调用的时候, 我给这个函数传递了一个实参
           在本次调用的时候, 给 dongwu 这个变量赋值为 '大象' 这个字符串
         bingxiang('大象')
    
           我本次调用的时候, 传递的是一个 '大熊猫' 字符串
           本次调用的时候, 冰箱帮我冻起来的就是 '大熊猫'
         bingxiang('大熊猫')
    
    
         多个参数
           赋值式函数里面, () 也是写形参的位置
         var bingxiang = function (dw1, dw2, dw3) {
            console.log('我接收到了三个动物, 他们分别是 ' + dw1 + ' ' + dw2 + ' ' + dw3)
            console.log('我要把他们三个都冻起来')
    
           console.log('我只要把 ' + dw1 + ' 冻起来')
    
         }
    
          调用的时候就传递三个参数
         bingxiang('大象', '长颈鹿', '大熊猫')

参数的个数关系
         + 因为有了实参, 有了形参
         + 因为出现在两个位置, 就会有多少的关系
           => 实参和形参一样多
             -> 形参和实参按照 从左到右 的顺序一一对应
           => 实参多
             -> 在函数内部没有形参接收这个传递进来的值
             -> 我们不能直接使用
           => 形参多
             -> 在函数内部的时候, 多余出来的形参
             -> 没有对应的实参赋值
             -> 在函数内部使用这个多出来的形参的时候
             -> 就是 undefined, 是一个声明了, 但是没有赋值的状态


总结一下函数
+ 函数就是帮我们把一段代码(一个功能)封装起来
  => 放在一个盒子里面
  => 就好像冰箱, 是把一个制冷的功能封装了起来
+ 函数的形参, 就是一个在函数里面可以使用的变量
  => 我们在函数调用的时候, 传递实参来给对应的形参赋值
  => 就好像冰箱, 你把 大象 放进去, 那么他就冷冻大象
  => 因为有的时候实参不确定, 我们说了一个 arguments
+ 函数的返回值, 就是函数执行你封装好的功能以后给你的一个东西
  => 我们在函数调用以后, 可以接收到的一个结果
  => 就好像冰箱, 你把 大象 放进去, 那么他就给你一个 冰冻大象
</body>
</html>